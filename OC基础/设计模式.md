## 设计模式

- 原型模式
  使用原型实例创建对象，并通过复制这个原型创建新的对象
  NSArray的copy方法就是这种模式
  这样可以提升创建实例的效率
  ```
  NSArray *array = [[NSArray alloc] initWithObjects:@1, nil];
  NSArray *array2 = array.copy;
  ```
- 工厂模式
  定义创建对象的接口，子类决定实例化哪一个类，工厂方法使得类的实例化延迟到子类
  以NSArray为例，NSArray和NSMutableArray的alloc方法会生成一个__NSPlaceholderArray类的对象，再由他作为工厂调用init方法产生真正的对象
  ```
  id obj1 = [NSArray alloc]; // __NSPlaceholderArray *
  id obj2 = [NSMutableArray alloc]; // __NSPlaceholderArray *
  id obj3 = [obj1 init]; // __NSArrayI *
  id obj4 = [obj2 init]; // __NSArrayM *
  ```
- 单例模式
  ```
  static SingleClass *instance = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    instance = [SingleClass new];
  });
  return instance;
  ```
- 观察者模式
  定义对象的一对多的依赖关系，当一个对象的状态发生改变时，依赖的对象都得到通知并自动更新
  Cocoa Touch框架中通知和KVO都实现了观察者模式，通知由一个中心对象为所有的观察者提供变更通知，KVO是被观察者的对象直接向观察者发送通知
- 组合模式
  将对象组合成树形结构表示“部分-整体”的层次结构，使得对单个对象和组合对象的使用具有一致性
  UIView的结构就是一个组合结构，可以将其他的UIView设置为自己的子视图，形成一个树形结构，操作父UIView时可以统一操作子UIView
- 迭代器模式
  NSEnumerator就实现了迭代器模式，用于顺序访问
- 装饰模式
  动态的给一个对象添加一些额外的职责，用于扩展功能
  Category就是实现了装饰模式，通过Category可以给类添加方法的接口与实现
- 责任链模式
  使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间发生耦合
  将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理他为止
  Cocoa Touch中的事件处理流程--响应者链就实现了责任链模式
- 模板模式
  定义一些方法，将操作延迟到子类中实现
  例如UIView中的drawRect方法，默认什么都不做或者只做了部分操作，用于给子类进行实现的方法
- 命令模式
  将请求封装为一个对象，用不同的请求对客户参数化，对请求排队或记录请求日志，以及支持可撤销的操作
  Cocoa Touch的NSInvocation就是实现了命令模式
- 享元模式
  利用共享技术有效的支持大量对象
  tableViewCell的重用机制就是享元模式
